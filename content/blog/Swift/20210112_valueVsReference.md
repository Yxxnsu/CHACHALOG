---
title: '🕊 [Swift] 값형식 vs 참조형식'
date: 2021-01-12 02:00:00
category: 'Swift'
draft: false
showToc: true
---

# Value Types vs Reference Types
 
값형식(Value Types)
- Structure
- Enumeration
- Tuple

</br>

참조형식(Reference Types)
- Class
- Closure

</br>

스위프트에서 값형식으로 분류되는 것은 구조체, 열거형, 튜플임.  
Int나 String 같은 기본 자료형은 구조체로 구현되어 있고,  
스위프트 컬렉션 역시 구조체로 구현되어 있음.

나머지 클래스와 클로저는 참조 형식으로 분류함.

좌표를 저장하는 구조체와 클래스를 선언해보쟈.

```swift
// 구조체
struct PositionValue {
    var x = 0.0
    var y = 0.0
}

// 클래스
class PositionObject {
    var x = 0.0
    var y = 0.0
}
```

속성은 선언과 동시에 기본값을 저장하고 있는데,  
파라미터가 없는 생성자가 자동으로 제공됨.  
이것을 **기본 생성자(Default Initializer)** 라고 함.

 
기본 생성자를 호출해서 인스턴스를 하나씩 만들어보자.

```swift
var v = PositionValue()
var o = PositionObject()
```

![1](https://user-images.githubusercontent.com/55340876/110789588-62023200-82b3-11eb-9cef-b26d969fbdec.png)

구조체 인스턴스와 클래스 인스턴스 모두 기본 생성자를 통해 같은 값으로 구현했기 때문에  
동일한 값을 갖고있음. (모두 0으로 초기화 되어있음)


새로운 변수를 선언한 후에 `v`와 `o`에 저장된 값으로 초기화하자.

```swift
var v2 = v
var o2 = o
```

![2](https://user-images.githubusercontent.com/55340876/110789586-62023200-82b3-11eb-96d1-3b7c7fc3153b.png)

현재까지는 모든 인스턴스에 동일한 값이 저장되어 있음.

`v2`에 저장되어 있는 속성을 다른 값으로 바꿔보자.

```swift
v2.x = 12
v2.y = 34

v
v2
```

![3](https://user-images.githubusercontent.com/55340876/110789585-61699b80-82b3-11eb-8112-7a1ca6849aa8.png)

`v2`에는 방금 바꾼 값이 저장되어 있음.

원래는 `v2`에 `v`를 저장하고 있는데 구조체는 값형식이라 `v2`에 저장된 값은 `v`와 같은 값을 가진 복사본임.    
`v2` 속성을 바꿔도 `v`는 아무런 변화가 없음!

같은 방법으로 `o2`에 저장되어 있는 속성의 값을 바꿔보자.

```swift
o2.x = 12
o2.y = 34

o
o2
```

![4](https://user-images.githubusercontent.com/55340876/110789583-60386e80-82b3-11eb-85be-458cb686d07f.png)

`o`와 `o2` 변수는 같은 값이 저장됨.

클래스는 새로운 복사본을 생성하지 않고, 원본을 전달함.  
정확히는 참조를 전달함.

원본이 전달되기 때문에 어떤 변수를 통해서 속성을 바꾸더라도  
항상 같은 대상을 바꾸게 됨!!

이것이 값형식과 참조형식의 가장 큰 차이임.  
값형식을 다른 곳에 저장하거나 파라미터와 리턴형으로 전달하면 새로운 복사본이 생성됨.

![5](https://user-images.githubusercontent.com/55340876/110789579-5f9fd800-82b3-11eb-8d60-436fff2e222f.png)

여기서 `v2` 변수를 `v`로 초기화할 때 저장되는 것은  
원본이 아니라 새로 생성된 복사본임.

즉, `v`와 `v2`가 저장되어 있는 곳은 서로 다른 메모리 공간이라  
`v2` 변수를 통해 속성을 바꾸더라도 `v` 변수에는 아무런 변화가 없음.

참조형식은 복사본을 생성하지 않고,  
인스턴스가 저장되어 있는 메모리 주소를 전달함.

주소와 값을 별도에 메모리 공간에 하나씩 전달하고,  
주소를 통해 값에 접근함.

![6](https://user-images.githubusercontent.com/55340876/110789573-5e6eab00-82b3-11eb-95f3-70b628541061.png)

여기서 `o2` 변수를 `o`로 초기화할때는  
새로운 복사본은 생성되지 않음.

`o2` 변수에 저장되는 것은 인스턴스가 저장되어 있는 메모리 주소임.  
마찬가지로 `o` 변수에도 값이 아니라 값이 저장되어 있는 메모리 주소가 저장되어 있음.

`o2` 변수와 `o` 변수를 통해 메모리에 접근하면  
결과적으로 동일한 인스턴스가 저장되어 있는 메모리 공간에 접근하게 됨.

값형식과 참조형식 중 어느것을 선택해서 새로운 형식을 만들까?  
답은 없음!!

두 형식의 차이점을 이해하고 구현 목적에 맞게 선택하는 것이 중요함.

</br>

**객체지향 프로그래밍에서는 대부분 참조 형식인 클래스로 구현함.**
- 상대적으로 적은 데이터를 저장하고 상속이 필요하지 않다면 값형식으로 구현
- 값이 전달되는 시점마다 복사본이 생성되어야 하는 경우에도 값형식으로 구현
- 연관된 상수 그룹을 표현할 때는 열거형으로 구현
- 코드내에서 한번만 사용되는 형식은 튜플로 구현
- 나머지 값형식은 모두 구조체로 구현
- 함수형 프로그래밍과 프로토콜 지향 프로그래밍에서는 주로 구조체로 구현
- 상속을 구현하거나 참조를 전달해야하는 경우에만 클래스로 구현