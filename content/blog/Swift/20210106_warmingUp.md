---
title: '🕊 [Swift] Warming up'
date: 2021-01-06 01:00:00
category: 'Swift'
draft: false
showToc: true
---

# Xcode 실행화면
![1](https://user-images.githubusercontent.com/55340876/110201163-0267e900-7ea5-11eb-8eb6-fc8ce85b6ca4.png)


# Warming up
# 프레임워크 Framework
특정 기능을 구현한 코드를 하나의 이름으로 포장해둔 것

 

# 토큰 Token
- 문법적으로 더이상 나눌 수 없는 요소
- 언어를 구성하는 다양한 요소중에서 공백, .으로 분리할 수 없는 가장 기본적인 가장 작은 단위의 요소
- 더이상 쪼갤 수 없는 원자와 같음


```swift
2+3; 

2 + 3 ; 

if // i f 로 쪼갤 수 없음
```

- 식별자 Identifier
- 키워드 Keyword
- 구둣점 Punctuation
- 연산자 Operator
- 리터럴 Literal 등...

# 표현식 Expressions
- 하나 이상의 토큰이 모여서 하나의 값을 도출하는 코드
- 값, 변수, 연산자, 함수 같은 것들이 하나 이상 모여서 하나의 값으로 표현되는 것
- '어떤 코드를 실행했을 때 결과로 하나의 값이 나왔다.' -> 표현식

# 평가하다 Evaluate
표현식은 하나의 변수 이름으로 구성된 단순한 형태도 있고,  
여러 연산자와 변수가 조합된 복잡한 형태까지 매우 다양하다.  

- 표현식을 통해서 하나의 결과값을 도출하는 것 -> '표현식을 평가한다' 라고 표현
- '평가한다' -> '코드를 실행해서 값을 얻는다'고 이해하셈!
 

# 문장, 구문 Statements
하나 이상의 표현식이 모여 특정 작업을 실행하는 코드

- if
- switch
- guard
- for-in
- while 등...

# 컴파일 Compile

<img width="400" alt="2" src="https://user-images.githubusercontent.com/55340876/110201162-ff6cf880-7ea4-11eb-83e9-b1b495f54044.png">

사람이 이해할 수 있는 텍스트를 컴퓨터가 이해할 수는 없음!  
0과 1 밖에 해석하지 못함.  

우리가 텍스트로 작성한 코드를 컴퓨터가 이해할 수 있도록  
**바이너리 코드(binary code)**로 바꿔줘야 함..!  
이 과정을 **컴파일(Compile)**이라고 함.  

컴파일이 완료된 코드는  
0과 1로 구성된 바이너리 코드로 변환됨.  
변환에 필요한 도구는 Xcode에 내장되어있고 이것을 **컴파일러**라고 함.  

컴파일러는 소스 코드를 분석한 후,  
오류가 없는 경우에만 바이너리 코드를 생성함.

컴파일러는 소스 코드를 분석할 때   
**경고(Warning / 노란색 삼각형)**와 **오류(Error / 빨간색 원)**로 분류함.  
(컴파일러가 잡아낼 수 없는 오류도 상당히 많..)

컴파일러가 오류없이 정상적으로 바이너리 코드를 생성했다해서  
바로 실행할 수 있을까?! ㄴㄴ  
ㄴㄴ  
ㄴㄴㄴㄴㄴ

수천개의 파일과 몇만줄 이상의 코드들을 연결하는 과정이 완료되어야  
실행 가능한 파일이 생성되는데 이 과정을 **링크(Link)**라고 하며,  
링크를 담당하는 코드도 Xcode에 내장되어 있는데 이 도구를 **링커**라고 함.  

예전에는 컴파일과 링크를 실행하기 위해 복잡한 명령어를 직접 입력 했지만  
요즘은 개발 도구가 다 처리해줌.  
이~편한~세상~~  

엑스코드는 **cmd+R** 만 누르면 알아서 해줌.  

현대적인 개발 도구들은 **통합개발환경(Integrated Development Environment)** 형태로 제공됨.  

<img width="200" alt="2" src="https://user-images.githubusercontent.com/55340876/110201158-fd0a9e80-7ea4-11eb-91e0-f9ddfbedddf2.jpeg">

**Xcode 역시 IDE!!!**

1. 코드 작성  
2. 컴파일 (바이너리 코드로 변환)  
3. 프레임워크나 라이브러리에 포함된 코드가 연결됨(Link)  
4. 링크까지 완료되면 시뮬레이터나 실제 디바이스에서 실행될 수 있는 실행파일이 생성됨  

이 모든 과정이 **Build** 임!  
빌드는 컴파일과 링크만 포함되는 것은 아니고,  
필요에 따라 정적분석, 유닛테스트 같은 부가적인 작업이 포함될 수 있음.

# 실행파일 생성방법
## 첫번째 디버그모드(Debug Mode)
- 디버그모드는 주로 개발과정에서 사용(오류를 찾는게 중요하니까!)  
- 실행파일에 오류를 찾는 정보(디버그정보)가 포함됨  
- 이 때문에 실행파일의 크기가 상대적으로 커지는 단점이 있지만 프로그램 오류를 쉽게 찾을 수 있음  
그니까 즉, **앱을 만들 때 사용! (앱스토어에 올릴때는 이 모드로 올릴 수 없음)**

## 두번째 릴리즈모드(Release Mode)
- 릴리즈모드에서는 디버그 정보가 포함되지 않아서 실행파일이 상대적으로 작아짐
- 최적화를 하기 때문에 실행속도도 빨라짐  
**앱스토어에 앱을 올릴 때 사용함**  
 

# 컴파일 타임(Compile Time)
: 코드를 작성하고 컴파일과 링크를 완료해서 실행파일이 생성되는 시점까지를 말함

# 런타임(RunTime)
: 실행된 생성 파일을 시뮬레이터나 실제 디바이스에서 실행하는 시점

ex)  
예를들어 `is` 연산자는 데이터의 실제 자료형을 런타임에 확인함.  
`is` 연산자의 실행결과를 확인하려면 단순히 코드를 컴파일하는 것으로는 불가능함.  
코드를 정상적으로 컴파일한 후, 실행해야 `is` 연산자의 결과를 확인할 수 있음!  

 
# Special Characters
**```!``` (Exclamation Mark)**
- 논리를 부정
- 옵셔널에서는 저장되어 있는 값을 강제로 꺼낼 때 사용

 

**```~``` (Tilde)**
- 비트 연산자에서 사용

 

**``` ` ``` (Grave Accent / Back Tick)**
- 키워드를 식별자로 바꿀 때 사용

 
**```@``` (At Symbol)**
- 코드 자체의 특성을 지정하는 용도로 사용

 

**```#``` (Sharp / Pound / Hashtag**
- 특별한 명령어들이 #으로 시작

 

**```$``` (Dollar Sign)**
- 클로져에서 파라미터 이름을 대체할 때 주로 사용

 

**```%``` ( Percent Sign)**
- 주로 나머지 구할 때 사용

 

**```^``` (Caret)**
- 비트 연산에서 사용

 

**```&``` (Ampersand)**
- 주로 메모리 주소를 얻거나 참조를 전달할 때 사용

 

**```*``` (Asterisk)**
- 곱하기 연산에서 사용

 

**```( )``` (Parentheses)**
- 함수를 호출할 때, 계산 순서 지정할 때도 사용

 

**```-``` (Minus Sign / Hyphen)**

 

**```_``` (Underscore)**
- 와일드카드 패턴을 구성할 때 자주 사용

 

**```=``` (Equal Sign)**
- 변수, 상수의 값을 저장할 때 사용

 

**```+``` (Plus Sign)**

 

**```[ ]``` (Square Bracket)**
- 주로 컬렉션에 저장된 값에 접근할 때 사용 (서브 스크립트 문법)

 

**```{ }``` (Curly Bracket / Brace)**
- 주로 코드블럭의 범위를 지정할 때 사용

 

**```\``` (Backslash)**

 

**```|``` (Vertical Bar / Pipe)**
- 주로 논리 연산이나 비트 연산에서 사용

 

**```;``` (Semicolon)**
- 문장 끝을 자동인식하는 스위프트는 별로 사용 안함

 

**```:``` (colon)**
- 자료형을 지정할 때, 딕셔너리에서 키, 값을 구분할 때 사용

 

**```,``` (Comma)**
- 함수로 전달되는 값을 나열, 배열의 저장할 값을 나열할 때 사용

 

**```.``` (Period)**
- 주로 메서드 호출이나 속성에 접근할 때 사용

 

**```< >``` (Angle Bracket)**
- 크리를 비교하는 연산자, 제네릭에서는 형식 파라미터를 지정할 때 사용

 

**```/``` (Slach)**
- 주로 경로를 지정할 때 사용

 

**```?``` (Question Mark)**
- 옵셔널에서 주로 사용

 

 

# First Class Citizen(1급 객체)
- 상수와 변수에 저장할 수 있음
- 파라미터로 전달할 수 있음
- 함수에서 리턴할 수 있음
 

# 변수 / 상수(Variables and Constants)
`var` 변수  
: 변수에는 언제든 새로운 값을 저장할 수 있음

`let` 상수  
: 한번 값을 저장하면 이후에는 새로운 값을 저장할 수 없음


- 변수와 상수는 선언된 후에 특징을 변경할 수 없음
- 이름과 저장된 값의 형식을 바꿀 수 없음  
(변수 선언 후 정수를 저장했는데 문자열을 저장하도록 바꾸거나 상수로 바꿀 수 없음,  
상수로 선언한 후에 문자열로 저장했는데 정수로 저장하거나 변수로 바꿀수 없음)
 
</br>

**스위프트에서는 상수를 주로 씀**  
왜?

- 실수로 값을 변경하는 경우가 없음(컴파일 오류가 나기 때문에 컴파일 시점에 미리 발견할 수 있다)
- 컴파일러가 별도의 최적화를 해주기 때문에 코드가 조금 더 빠르게 실행됨

</br>

일단 상수로 선언하고 나중에 값을 변경하는 경우가 있다면,  
그때 변수로 바꾸자! (let -> var)

# 이름 정의 규칙(Naming Convention)
**카멜 케이스 (UpperCamelCase, lowerCamelCase)**

**UpperCamelCase**  
- Class
- Structure
- Enumeration
- Extension
- Protocol

**lowerCamelCase**  
- Variable
- Constant
- Function
- Method
- Property
- Parameter
 

머리로 암기 말고 직접 코딩하면서 손가락으로 암기할 수 있도록  
연습을 많이 해주자!  


# 범위(Scope)
- 변수, 상수는 자신만의 스코프를 갖고있고 선언 위치에 따라 결정됨
- 자신이 속한 범위내에서 항상 유일한 이름을 가져야함 (서로 다른 스코프라면 이름이 같아도 상관없음)

</br> 

그래야 이름을 통해서 접근할 때 원하는 대상에 정확히 접근할 수 있다.   
(만약 동일 범위에 이름이 중복된 변수가 있다면 어떤 변수에 접근할지 모호해지니까!)

범위를 구분하는 기준은 `{}` brace에 따라 다름.  
브레이스는 코드의 범위를 지정한다.

 
```swift
// 전역스코프

func doSomething() {
  
  // 지역스코프

  if true {
    // 지역스코프
  }

  // 지역스코프

}

// 전역스코프
```

## 전역 스코프 Global Scope
- 어떠한 브레이스에도 속하지 않음
- 브레이스 밖에서 선언된 변수는 전역범위에서 선언됐기 때문에 전역변수이다.

## 지역 스코프 Local Scope
- 브레이스 내에 속함
- 글로벌스코프는 단 하나만 존재하지만 로컬스코프는 여러개 존재할 수 있음
- 중첩될 수 있음 (이건 선언 범위(Declaration Scope)랑 같이 나중에 알아보자)

## 스코프 규칙
1. 동일한 스코프에 있는 변수, 상수에 접근할 수 있음
2. 동일한 스코프에서는 이전에 선언되어 있는 변수, 상수에 접근할 수 있음
3. 로컬스코프에서는 자신의 상위스코프나 글로벌스코프에 선언된 변수, 상수에 접근할 수 있음  
(코드는 위에서 아래로 흐르는데 아직 선언되지 않은 변수, 상수의 접근을 허용하지 않음)
4. 상위스코프에서는 하위스코프에 접근할 수 없음
5. 서로 다른 스코프에 동일한 변수, 상수가 존재한다면 가장 인접한 스코프에 있는 변수, 상수를 사용함
 
</br>

**스코프는 라이프사이클에도 영향을 주는 것을 명심하자!**
스코프는 정말 중요한 내용이니까 반복 학습하쟈!!

 
# 데이터 타입(자료형)과 메모리
자료형은 메모리에 저장되는 데이터의 종류와 크기를 결정함  

## 기본 자료형 (Built-in Data Type)
- Integer Types  
- Floating-point Types  
- Boolean Types  
- Character Types  
- String Types  
 

## 사용자 정의 자료형(Custom Data Type)
 

 

## Memory
모든 데이터가 메모리에서 저장되고 메모리에서 처리됨.  

**메모리**는 1과 0을 저장할 수 있는 저장공간을 가진 반도체임!  
메모리는 전압차이를 이용해서 데이터를 저장하고,  
전기가 들어오면 1, 전기가 들어오지 않으면 0이 저장됨

메모리 저장단위를 알아봅세.

## Bit
- 0과 1만 저장하는 가장 작은 공간
- 정보의 기본단위

## Byte
- Bit가 8개 모인 것
- 프로그래밍 언어의 기본단위
 
</br>

컴퓨터는 데이터의 종류에 관계없이 항상 이진수(0과 1)로 바꿔서 메모리에 저장함  
1byte는 8bit 인데, 00000000 ~ 11111111  
8개의 비트로 표현할 수 있는 경우의 수는 256개임!  


이런 경우의 수로 표현할 수 있는 범위를 보면  
양수만 저장할 경우 0 ~ 255 까지 저장할 수 있고,  
양수, 음수 모두 저장한다면 -128 ~ 127까지 저장할 수 있음.  

 

1byte 메모리에 22는 어떻게 저장이 될까?  
22를 이진수로 바꾸면  

![스크린샷 2021-03-06 오후 6 18 44](https://user-images.githubusercontent.com/55340876/110202385-7dcc9900-7eab-11eb-9827-6d54b039e8ba.png) 

가장 왼쪽에 있는 비트를 **최상위 비트(MSB: Most Significant Bit)**라 부르고,  
가장 오른쪽에 있는 비트를 **최하위 비트(LSB: Least Significant Bit)**라 부름.  


실제 데이터를 저장하고 있는 전체 비트를 **데이터 비트(Data Bit)**라 함  

 

양수만 저장하는 경우, 8개의 비트를 모두 데이터 비트로 사용하기 때문에  
0 ~ 255까지의 숫자를 저장할 수 있지만  
반대로 양수, 음수를 모두 저장해야 한다면 저장방식이 달라짐.  

 
음수, 0, 양수를 모두 저장할 수 있다면 Signed 자료형이라 함(앞에 부호를 붙인다는 의미)  
음수를 저장할 수 없고, 양수와 0만 저장할 수 있다면 Unsigned 자료형.  

 

메모리에는 1과 0만 저장됨  
음수 즉, 마이너스 문자는 메모리에 직접 저장할 수 없어서 0과 1로 표현해야 함!  

 

최상위 비트값이 **0(Positive Number)**이면 **양수**고, **1(Negative Number)**이면 **음수**임  
이런 역할을 하는 비트를 **부호비트(Sign Bit)**라 함.

 

비트가 8개인데,  
양수와 음수를 표현하기 위해 하나의 비트를 사용하고 있고,   
그러면 실제 데이터를 저장하는 비트는 7개.  
그래서 이런 차이점으로 저장할 수 있는 값의 범위가 달라짐  

 

음수 저장 방법을 더 알아봅세.

 

요즘은 2의 보수 방식을 사용함  
양수의 비트 값을 **Bitwise NOT 연산** 한다음 1을 더해서 음수를 표현함.  
Bitwise NOT 연산은 비트가 1인 경우 0으로 바꾸고, 0인 경우 1로 바꾸는 비트 연산임.

 

-22를 2의 보수 방식을 사용해서 이진수로 표현해봅세!

 

먼저 22를 이진수로 바꿔 00010110 이 되고,  
Bitwise NOT 연산을 수행해서 0은 1로, 1은 0으로 바꿔서 11101001 이 됨.  
그런 후 1을 더하면 11101010 이 됨.  
고로 -22의 이진수 값은 11101010~  

![스크린샷 2021-03-06 오후 6 18 54](https://user-images.githubusercontent.com/55340876/110202384-7d340280-7eab-11eb-9a22-5dbc9139447a.png)

실수를 저장하는 방법은 뭘까?  
컴퓨터에서 고정소수점은 저장이 불가하니까 부동 소수점 방식을 사용함.

![스크린샷 2021-03-06 오후 6 19 03](https://user-images.githubusercontent.com/55340876/110202382-7c02d580-7eab-11eb-8213-17df0fab1b66.png)


실수를 저장할 때는 3가지만 암기하자!!!  
1. 지수와 가수를 나눠서 저장함  
2. 동일한 메모리 크기에서 정수에 비해 더 넓은 범위를 표현할 수 있음  
3. 부동 소수점 오차로 인해 100프로 정확한 실수를 저장할 수 없음  

 

메모리에 값을 저장했으면 거기에 접근해서 사용해야 하는데, 그 때 필요한 것이 **메모리 주소**임.  
 

메모리 내부에는 1바이트를 저장할 수 있는 공간마다 메모리 주소가 할당되어 있고,  
CPU는 이 주소를 통해 메모리에 접근함.
바이트별로 순서대로 0번부터 ~ 머머번까지 주소가 할당됨!!  
CPU가 첫번째 메모리에 접근하고 싶으면 0번 주소, 마지막 메모리면 마지막 번 주소를 사용함.

 

CPU가 작업을 처리하려면 메모리 주소에 접근해서 데이터를 가져와야 하는데,  
이 때 특정 위치에 접근하기 위해 **주소 레지스터**를 사용함.

 

우리가 CPU를 구입할 때 스펙을 보면 얜 32비트 쟨 64비트 이러잖아?  
여기에서 32비트 CPU라고 하면 주소 레지스터의 크기가 32비트라는 말이고,  
이 경우엔 모두 32억개의 메모리 주소에 접근할 수 있음.  
이 32Bit를 GB로 환산하면 4GB임  
요즘은 대부분 64Bit니까 접근할 수 있는 메모리 주소는 1800경임.  
환산하면 16EB임..... 어마마마마마마ㅏㅁ하지?  
