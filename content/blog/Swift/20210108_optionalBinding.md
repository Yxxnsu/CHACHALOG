---
title: '🕊 [Swift] 옵셔널 바인딩'
date: 2021-01-08 02:00:00
category: 'Swift'
draft: false
showToc: true
---

옵셔널 형식에는 값을 저장할 수도, 저장하지 않을 수도 있음  
값을 저장하지 않을 때는

```swift
var num: Int? = nil
```

이런식으로 nil을 저장함

옵셔널은 값이 포장되어 있어서 값을 꺼내야 하고,  
이것을 <span style="color: red;">**언래핑**</span> 이라고 함

```swift
var num: Int? = nil
print(num!)
```

이런식으로 옵셔널 표현식 뒤에 `!` 를 이용해서 강제 추출을 진행하는데,  
상단 코드는 당연히 에러 뿜!

왜??  
**값이 저장되어 있지 않은데 강제로 추출하니까!!**

이럴 때는 뭐라했냐?

```swift
var num: Int? = nil
print(num!) // 값이 없으니 에러발생!!

// if문으로 값이 있는지 확인하고 강제추출을 진행
if num != nil {
print(num!)
}
```

이렇게 값의 존재유무를 확인 후, 강제 추출을 진행함  
실제로는 상단 코드처럼 작성하는 경우는 거의 없음!

이 부분을 <span style="color: red;">**옵셔널 바인딩**</span>을 이용해서 작성하면  
안전하고, 직관적인 코드를 작성할 수 있음.

알아보쟈알아보쟈!

# 옵셔널 바인딩(Optional Binding)

```swift
if let 상수명: 타입 = 옵셔널표현식 {
    실행구문
}

while let 상수명: 타입 = 옵셔널표현식 {
    실행구문
}

guard let 상수명: 타입 = 옵셔널표현식 else {
    실행구문
}
```

원래였으면 조건이 오는 자리지만  
`let ~ brace {}` 전까지의 코드를 **binding** 이라고 불러줍세.  
바인딩은 코드가 실행되는 조건이 좀 다름.

상단 코드를 봅세.

먼저 옵셔널 표현식을 평가하고,  
값이 리턴이 된다면 언래핑 되어서 상수에 저장됨(그냥 저장되는게 아니라 언래핑 되어서 저장!)  
이 상태가 **바인딩이 성공**한 상태고,  
if문에서는 if블럭이 실행되고,  
while문에서는 반복 코드가 실행되고,  
guard문에서는 else블럭이 아니라, else 블럭 다음의 코드가 실행됨

반대로 옵셔널 표현식을 평가했는데 nil이 리턴이 되면 **바인딩을 실패**한거임.  
if문과 while문은 다음 문장으로 제어를 넘기고,  
guard문에서는 else문을 실행함.

옵셔널 표현식이 값을 리턴하는 경우에만 언래핑하기 때문에  
강제추출과 같은 에러는 발생하지 않음!!! (코드가 안전해짐!)

<span style="color: red;">**앞으로는 강제추출을 사용하지 말고 옵셔널 바인딩을 사용하삼!  
(옵셔널 때문에 발생하는 크래시를 대부분 피할 수 있으니!)**</span>

## 예시1)

![1](https://user-images.githubusercontent.com/55340876/110230261-11a57000-7f53-11eb-9976-87b89b7c60bc.png)

상단 옵셔널 바인딩 부분 코드에서  
`print(n)` 타입을 보면 Int형으로 확인할 수 있음!!! 오호..

`print(n)` 을 -> `print(n!)` 을 하면 에러남.  
이미 추출된 값을 다시 추출할 수는 없으니께!!

여기서는 상수 이름을 그냥 `n`으로 하고있는데  
`if let num = num { }`  
**옵셔널 바인딩을 요래 같은 이름을 사용해도 전혀 문제 없이 실행됨.  
다만, 스코프에 대해서 정확히 알고 있어야 함!**

`if let num = num { }`  
`let num` 은 if 블럭에서 사용하는 임시 상수  
`= num` 은 최상단에 선언한 변수임.  
두개는 분명히 다르니 정확히 알고하삼!

그리고 `print(num)` 은??  
옵셔널 바인딩으로 생성한 상수는  
바로 이어지는 로컬 블럭에서 사용함.  
(**서로 다른 스코프에서 같은 이름을 가진 식별자가 있다면 가장 인접한 스코프에 있는 식별자를 사용함)**

위치상 `let num` 이 가깝기 때문에 이 임시상수 num을 사용함.

## 예시2)

![2](https://user-images.githubusercontent.com/55340876/110230258-110cd980-7f53-11eb-9570-7cdc674030a4.png)

else 블럭에서는 바인딩할 상수를 이용할 수 없음!!!  
꼭고꼬꼬꼮꼭꼭 명심하삼!!

지금까지는 옵셔널 바인딩에서 상수로 바인딩 했음  
상수기 때문에 바인딩한 값을 바꿀 수 없겠지?!  
만약 값을 바꿔야 한다면??  
변수로 바인딩하면 됨!!!

guard문 까먹었니?

[🕊 [Swift] guard문](https://chajinjoo.netlify.app/Swift/20210107_guard/)

**guard문에 else 블럭 필수인거 알제??  
else 블럭에서는 무조건 코드의 실행을 중지시켜야 하는 것 알제??  
이놈은 대부분 로컬 스코프에서 사용하는 것도 알제??  
까먹으면 안되는거 알제??**

ㅋㅋㅋㅋㅋ 다시 돌아와서 보쟈... 내가 지금 그러는 중...

상단 코드에서 `fatalError()` 는 호출 즉시 크래시를 발생하는 메서드임  
메서드에서 리턴할게 없거나~ 에러가 치명적일 때!  
프로세스 강제 중지! 크래시를 내서 앱을 죽이는거.  
걍 알아두삼!

## 예시3)

![3](https://user-images.githubusercontent.com/55340876/110230257-10744300-7f53-11eb-9884-47aa7245b646.png)

보통은 상수로 바인딩하지만  
요로코롬 필요에 따라 변수로 바인딩하는 것도 가~넝!!

## 예시4)

![4](https://user-images.githubusercontent.com/55340876/110230256-0fdbac80-7f53-11eb-9fa8-d0bd470c9112.png)

이렇게 하나의 문장에서 여러 바인딩을 동시 사용할 수도 있음

상단 코드를 보면 최상단에 옵셔널 상수를 2개 선언해주고,  
`a` 상수에 저장된 값을 `num` 상수로 바인딩,  
`b` 상수에 저장된 값을 `str` 상수에 바인딩,  
그리고 조건을 추가해서 문자열 길이까지 확인함.

즉, 두개의 바인딩이 모두 성공하고 + 저장된 문자열 길이가 5를 초과한 경우에만  
if 블럭이 실행됨  
어느 하나라도 바인딩에 실패하거나,  
바인딩에는 성공했으나 조건이 false면 else 블럭이 실행되는거임.

요 경우에는 바인딩은 성공적이나 조건이 false라 else 블럭이 실행됨.

다른 경우를 함 더 볼까?

![5](https://user-images.githubusercontent.com/55340876/110230255-0e11e900-7f53-11eb-95b1-fbe08930cb47.png)

바인딩 성공적.  
조건 성공적.  
펄펙ㅌ
